### 前端面试题 - 计算机网络

### 1. GET 和 POST 请求的区别

- GET 用于获取资源；POST 用于提交数据
- GET 参数在 URL 中，POST 参数在请求体。
- GET 参数可见不安全，POST 参数不可见较安全
- GET 可被缓存，POST 不可以
- GET 受 URL 长度限制，POST 无限制。HTTP 协议并没限制长度，是浏览器限制。

### 2. POST 和 PUT 请求的区别

- POST 主要用于提交数据创建资源
- PUT 主要用于更新资源，客户端传送的内容通常会完全替代目标资源

### 3. HTTP 状态码 304

- 304 标识资源未修改，是缓存机制中常见的状态码。表示客户端可以继续使用缓存的资源
- 服务器可以通过 `If-Modified-since` 或 `If-None-Match` 来判断资源是否更新
- 不需要服务器重新响应资源，减少服务器的负担，性能好

### 4. HTTP 1.0 和 HTTP 1.1 的区别

HTTP 1.0

- 每次请求都重新创建 TCP 连接
- 不支持持久连接

HTTP 1.1

- 默认使用持久连接（`Connection:keep-alive`）
- 支持多个请求在同一个连接中发送，但是要保证顺序
- 新增 `Host` 字段，支持虚拟机

### 5. HTTP 1.1 和 HTTP 2.0 的区别

HTTP 1.1 

- 文本传输，不支持多路复用，必须按顺序发送请求和接收请求
- 头部信息未压缩
- 存在对头阻塞：一个请求延迟了，后续的请求都得等着

HTTP 2.0

- 二进制分帧传输，支持多路复用，不用按照顺序发送，不存在等待的问题，所以不会阻塞
- 头部信息压缩，较少带宽消耗
  - 头部压缩算法 HPACK 将一些常见的字段 get post 等放在索引表中，直接引用，无需传送完整字段

- 支持服务器推送，服务器未经过请求，主动向客户端发送资源

### 6. HTTP 和 HTTPS 协议的区别

- HTTP 是明文传输，不安全，默认端口是 80
- HTTPS 传输的信息使用对称加密，防止中间人攻击和篡改
- HTTP 是无状态连接。HTTPS 是由 HTTP 和 SSL/TLS 加密协议构建可进行解密传输和身份验证的网络协议比 HTTP 更加安全
- 底层一点：SSL 会在客户端和服务端开始连接前会握手交换密钥确认双方的身份，然后形成一个加密的信道，以后的通信都在这条信道中进行

### 7. TLS/SSL 的工作原理

- 非对称加密：用于密钥交换
- 对称加密：数据传输
- 散列函数：验证数据的完整性

### 8. HTTPS 的特点及如何加密

1. 客户端 -> 服务端：发送HTTPS请求，包含所支持的 TLS/SSH 协议版本和加密算法
2. 服务端 -> 客户端：发送 CA 证书，并根据客户端的加密算法发送公钥
3. 客户端 -> 服务端：客户端验证对方 CA 证书来源于可信机构后，使用它的公钥加密一个对称密钥并发送过去
4. 服务端 -> 客户端：服务端收到密钥之后使用私钥解密发回给客户端
5. 最后，客户端此时到验证服务器具有私钥来解密成功真正的对称密钥后，双方使用这个密钥建立加密信息通信

- 优点：安全性高，防止数据被盗窃或篡改（完整性）
  - 非对称加密安全传输会话密钥
  - 对称加密数据快速

- 缺点：性能开销大，需要额外的加密和解密操作

### 9. HTTPS 通信（握手）过程

1. 客户端发送 `ClientHello`，包含支持的加密算法
2. 服务器返回 `ServerHello`，选择加密算法并发送证书
3. 客户端验证证书并生成密钥，发送给服务器
4. 然后，双方使用密钥加密通信

> [!NOTE]
>
> 数字证书：用于验证服务器的身份，由可信机构发送，包含公钥和签名

### 10. 什么是 DNS 协议

DNS 协议用于域名解析，将域名转为 IP 地址。因此用户无需记住复杂的 IP 地址，记住域名就行。

DNS 同时使用 TCP 和 UDP

- UDP：常规的 DNS 查询
- TCP：主从 DNS 服务器之间数据同步

> [!WARNING]
>
> DNS 常见的安全问题：DNS 劫持，DNS 污染，DDos（淹没服务器）

### 11. DNS 完整查询过程

1. 首先检查浏览器缓存是否有解析记录
2. 再检查操作系统本地是否有解析记录
3. 再发送请求到本地 DNS 检查是否有解析记录
4. 如果本地 DNS 没有，再发送请求到根域名服务器，返回服务该域名的顶级域名服务器地址
5. 本地 DNS 再向顶级域名服务器发送请求，顶级域名服务器返回负责该域名的权威域名服务器
6. 本地 DNS 再向权威域名服务器发送请求，返回该域名的 IP
7. 最后本地 DNS 将 IP 地址返回给客户端，并缓存起来

### 12. 迭代查询和递归查询的区别

递归查询：客户端向 DNS 服务器发送请求，DNS 服务器负责完成整个查询过程并返回最终结果

迭代查询：查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出多次的查询请求

### 13. TCP 协议与 UDP 协议的区别

- TCP 是面向连接，进行可靠传输，有序的，适用于文件传输，邮件，面向字节流，提供拥塞控制，错误重传等机制
- UDP 是无连接，不可靠传输，无序，但是很高效，适用于视频会议，语音等对实时性要求高的场景，面向报文
- 相同点：TCP 和 UDP 底层都是基于 IP 协议的，IP 协议负责寻址和转发，TCP 和 UDP 负责不同类型的传输

> [!warning]
>
> TCP 的重传机制：
>
> 1. 累计确认序列号
> 2. 超时重传
> 3. 快速重传：三个ACK；若接受方收到顺序错乱的包，会立即返回三个 ACK，告诉发送方迅速恢复重传错误的包，减少了等待的延迟

### 14. TCP 协议的三次握手和四次挥手

三次握手：建立连接

1. 客户端发送`SYN`，并携带序列号。
2. 服务器返回`SYN-ACK`，序列号加 1。
3. 客户端发送`ACK`。

四次挥手：断开连接

1. 客户端发送`FIN`。
2. 服务器返回`ACK`。
   - 这个阶段还可以发送剩余的资源

3. 服务器发送`FIN`。
4. 客户端返回`ACK`。

### 15. 如何处理 TCP 粘包

TCP 粘包是指发送方连续发送的多个数据包在接收方接收时被合并成一个包的现象

出现原因：

1. TCP 是面向流的协议：数据以字节流形式传输，没有明确的消息边界。发送时有部分丢失了，那么他和之前的粘在一起了
2. Nagle 算法：为了提升效率，TCP 会将多个小数据包合并发送。
3. 接收缓冲区：接收方可能一次性读取多个数据包

解决方法：

1. 固定长度：每个数据包长度固定。
2. 分隔符：使用特殊字符标记数据包边界。
3. 长度字段：在数据包头部添加长度信息。

### 16. 对 WebSocket MQTT 的理解

- 全双工通信协议，允许实时传输
- 服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息
- MQTT 是一种发布/订阅的传输协议，依赖于 WebSocket/TCP 不依赖 HTTP

WebSocket 底层：

- 握手阶段：客户端通过HTTP发起WebSocket请求，服务器响应后升级为WebSocket协议
- 心跳机制：通过Ping/Pong帧来维持连接状态，检测连接是否正常
- 数据帧：分为控制帧和数据帧来传输数据

优点（相较于HTTP）

- HTTP是请求响应模式，WebSocket 是全双工通信模式
- WebSocket 减少HTTP头部的开销，性能更高

### 17. 常见的 HTTP 请求头和响应头

- 请求头：
  - `Accept`：客户端可接受的内容类型。
  - `user-Agent`：客户端浏览器设备的信息
  - `Content-Type`：请求体的数据类型（如`application/json`）。
  - `Authorization`：身份验证信息。
  - cookie
  - refer 来源页面
  - 缓存字段
- 响应头：
  - `Content-Type`：响应体的数据类型。
  - `Cache-Control`：缓存控制（如`max-age=3600`）。
  - `Set-Cookie`：设置Cookie。
  - 缓存策略

### 18. 常见的 HTTP 状态码

- 204 服务器处理了请求，但没有返回任何内容
- 301 网页已经移动到新位置，自动将请求者转到新位置
- 302 网页临时移动，但请求者应该使用原有的地址请求，服务器会从其他地方响应
- 304 内容未修改，请求者可以使用原有的内容
- 400 请求参数配置错误
- 401 未授权
- 403 拒绝，服务器拒绝，因为客户端权限不够
- 404 未找到
- 500 服务器内部错误
- 501 服务器不支持请求的功能
- 502 网关错误
- 503 服务器暂时不可用（过载）
- 504 网关超时

### 19. HTTP 3.0 做了哪些改进

已知 HTTP 协议是应用层协议，建立在传输层协议之上，而 HTTP 1.0/2.0 都是基于 TCP 的，而 3.0 是基于 UDP 的。

- 连接迁移
- 无对头阻塞
- 自定义的拥塞控制
- 前向安全和前向纠错

### 20. 线程和进程的区别

- 进程是操作系统调度的最小单位，线程是 CPU 调度的最小单位
- 进程有独立的内存空间，线程共享内存空间
- 进程间的资源独立，线程间的资源共享
- 进程崩溃不会影响其他进程，线程崩溃会导致进程崩溃

### 21. 什么是死锁

进程或线程在执行的过程中，因为竞争资源而导致互相等待的现象

如何解决

- 破坏互斥条件，允许资源共享
- 一次性申请所有资源
- 允许资源被抢占
- 按顺序申请资源

### 22. 数组和链表的区别

- 数组内存连续，查找的速度快，增删的速度慢，因为要移动元素
- 链表内存不连续，查找速度慢，增删速度快，只需改变指针的指向

### 22. 前后端实时通信

- 轮询：每隔段时间发请求，适合轻量应用
- 长轮询：发送请求，后端数据不更改就先不返回，但是连接不中断，如果后端数据更改了再响应
- iframe流：再页面中插入一个隐藏的iframe，利用其src属性在浏览器和服务器间建立一条长连接，服务器向iframe传输数据，来实时更新，适用客服通信
- WebSocket：建立类似 TCP 长连接模式，以帧序列的形式发送，不需要客户端重新给服务器发送请求，海量数据
- SEE：建立通信渠道，只能服务器给客户端推送，股票平台

### 23. 网络安全策略

- SSL/TLS 身份验证 加密传输
- CSP 内容安全策略 防止 XSS 攻击 在 `meta` 或 http 头中限制资源的加载和执行
- Samesite Cookie 防止 CSRF
- CORS 设置允许访问资源的源
- 防火墙 入侵检测 IDS
- 多因素验证
- 白名单 黑名单过滤
- 进程隔离 沙箱

### 24. 物理像素和逻辑像素

- 物理像素是屏幕的实际像素
- 逻辑像素是 CSS 的像素独立单位 （设备独立像素）
- 关系：在高清的设备上，一个逻辑像素可能对应多个物理像素

扩展：画一根物理像素 0.5px 的线

```css
.line {
	heaght: 1px;
}
@meadia screen and (-webkit-min-device-ratio: x) {
  .line {
    transform:scaleY(1px / x) /* 缩放 x 倍 */
  }
}
```

### 25. OSI 七层模型

意义：便于模块化开发，每一层间相对独立，下层给上层提供的接口，上层只需调用统一的接口就行，不用管下层的具体细节。同时方便故障的排查。

### 26. IP 地址和 MAC 地址

- MAC 物理地址 相当于身份证号 每个硬件独有，只能在局域网通信，无法跨网络
- IP 逻辑地址 相当于邮件地址 网络中的唯一标识，动态分配，用于跨网络通信，路由转发
- 整体：路由根据 IP 找到目标网络。通过 ARP协议 将 IP 转为 MAC 地址，在当前网络发送到目标设备

### 27. Cookie 的字段

- `max-age` 最大存活时间
- `SameSite` 是否允许跨站请求
  - `strict` 不允许
  - `lax` 部分允许
  - `none` 允许
- `HttpOnly`：禁止 `JS` 访问 Cookie ，防止 XSS
- `Secure`：仅允许 HTTPS 传输 Cookie
- `Expires` 过期时间

### 28. 正向代理和反向代理的区别

- 正向代理 代理的是客户端 去帮客户端请求服务器的资源 因为它自己存在同源策略请求不了
- 反向代理 代理的是服务器 去帮服务器响应客户端的请求 因为很多人访问同一服务器导致压力过大 要负载均衡

### 29. 什么是带宽

单位时间内传输的最大数据量（bit/s)

### 30. options 请求

再发送其他请求前，先发送一个 options 请求获取目标服务器所支持的通信选项。

- CORS 跨域资源共享预检请求
- 询问对方所支持的http请求方法

> [!NOTE]
>
> options请求是幂等的。即多次请求的执行结果，与第一次时相同。

### 31. 比较动态规划和递归

递归：

- 简洁，但可能存在重复的计算，大数据量下性能不好

动态规划：

- 他的目的就是为了避免一些重复的计算，所以大数据量下性能比递归好

### 32. 接收窗口和发送窗口

接收窗口：表示接收放还能接收的数据量，告诉发送方，防止发送过多而导致数据被淹没

发送窗口：发送方的发送缓冲区大小，控制发送方的发送数据量

### 33. HTTP 如何判断数据接收完成

- 服务器在响应头中指定 `content-length` 表示响应的字节数，客户端读取到这个数量的字节后，就知道数据接收完成了
- 对于动态生成的内容，服务器使用分块传输的形式，每个块前面有块的大小，最后一个块的大小为 0，表示传输结束。`Transfer-Encoding:chunked` 
- `Connection: close` 服务器显示的关闭了连接，因为在 HTTP/1.1 默认 Keep-Alive）

### 34. 预览和下载

- 预览：设置响应头 `content-Disposition:inline` 并在前端使用 `img` 标签进行预览
- 下载：设置响应头 `Content-Disposition: attachment; filename="example.txt"`，浏览器会提示用户下载文件（a标签点击触发`.download`事件）

### 35. 常用的数据结构和应用场景

- 数组：快速遍历查询修改
- 链表：频繁增删
- 栈：撤销操作
- 队列：任务调度
- 哈希表：快速查找和插入
- 树：层次结构，文件系统
- 图：网络结构，路由跳转

### 36. 快速排序的优缺点

- 最快：$O(n\log n)$ 本质上的分治排序，每次都将原始任务分为两半，只需遍历 $\log n$ 次
- 最慢：$O(n^2)$ 当数组有序时，每次划分都极不平衡，每次划分只减少一个元素，要遍历n次，加上每次遍历中要比较n次，就是$n^2$
- 缺点：以上最慢的一条。还有不稳定排序。相对位置发生变化

### 37. 对象的创建，在内存中是怎么做的

1. 在堆内存中分配一块连续的内存空间
2. 然后将这块内存的引用复制给变量，而不是将值直接覆给变量

### 38. TCP 的拥塞控制

目的：防止网络过载，保证传输可靠/效率

1. 慢启动：初始窗口为 1MMS（最大报文大小），每收到一个ACK窗口翻倍
2. 拥塞避免：每收到一个ACK，窗口加 1，线性增加
3. 快重传：连收到 3ACK，重传丢失报文
4. 快恢复：快重传后，窗口减半，进入拥塞避免阶段

### 39. 服务端向客户端推送的网络协议

- WebSocket *全双工* 通信协议，独立协议（ws/wss）
- SSE（Server-Sent-Events）基于 HTTP 的 *单向* 通信协议，服务端可以向客户端推送数据，支持断线重连
- HTTP2 Server Push：Http2支持服务端主动向客户端推送资源

### 40. TCP 为什么是四次挥手

因为 TCP 是全双工通信。允许数据双向传输。当一方关闭之后另一方还可以发送数据，一次需要每一方独立的关闭其发送信道，所以需要两次关闭过程，每一次都需要确认。

### 41. HTTP 报文格式

请求行：包含请求方法，请求url，协议版本

请求头：请求元数据 用户浏览器信息，Accept 接收的响应类型，cookie，token等

请求正文

```
GET /index.html HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0
Accept: text/html
```

### 42. 301 重定向之后使用什么请求方法

永久重定向。

如果时 GET 请求，重定向后请求方法不变

如果时 POST 请求，重定向后方法改为 GET

### 43. HTTP2 多路复用的原理

1. 将数据分割成更小的帧来传输，每个帧有一个唯一的流标识符
2. 一个 TCP 连接可以以同时承载多个流，每个流可以承载多个帧

### 44. 为什么 GET 请求要把参数放在 URL 中

- 语义化
- 可以被浏览器缓存

### 45. 端口号的作用及常见的服务端口号

用于区分同一台服务器上的不同服务

常见的服务端口

- HTTP 80 
- HTTPS 443
- DNS 53
- SMTP 25 邮件传输协议

### 46. 浏览器打开网页时会启动哪些线程/线程

进程

- 浏览器主进程：页面的显示，文件的交互
- 渲染进程
- GPU 进程
- 网络进程：HTTP 请求
- 插件进程

线程

- 光栅化线程：将图层转为位图（GPU 加速）
- Web Worker 线程
- Service Worker 线程：处理离线缓存和后台同步
- I/O 线程
- 存储线程

### 47. BFS 和 DFS 实现方式

1. BFS 广度优先按层遍历，适合最短路径问题
2. DFS 深度优先一条路走到底，递归来做

### 48. 封装、继承、多态

封装：隐藏内部实现，暴露接口，通过方法的方式访问

```js
class Person {
  #age; // 私有字段
  constructor(name) {
    this.name = name;
  }
  getAge() { return this.#age; } // 通过方法访问
}
```

继承：子类继承复用父类的特性

多态：同一方法可以有不同的表现，比如在之前的类中写了一个方法，我后来的类中可以覆盖该方法

### 49. 操作系统的作用

1. 统一管理计算机资源，是硬件与应用程序之间的桥梁
   - CPU 管理：时间片轮转，优先级调度
   - 内存管理
   - 设备管理
   - 存储管理
2. 隐藏硬件的复杂性，为上层用户提供清晰可用的接口

### 50. 虚拟内存及分页和分段

如果进程直接使用的是物理内存，那么必然导致内存访问的冲突。所以操作系统需要为每个进程分配独立的一套虚拟内存，以将进程所使用的地址分隔开。

1. 内存分段：根据段【选择因子+段偏移量】去物理内存中寻址（连续的内存空间）
   - 存在 *外部碎片* ，也就是一个进程释放后，这段内存可能卡在其他两个进程还没释放的中间，导致这块卡住的内存和外侧的内存没有合起来，导致这些内存不大不小的尴尬局面
   - 内存交换：为了解决内存碎片的问题，将还在内存中的段放到磁盘中，然后再从磁盘中读出来到内存里，接到上一个进程段内存的后面，这样他之后的空间就释放出来了，减少了内存碎片【但是效率很低哈，因为一次性 写入/交换 整个段】
2. 内存分页：将物理内存/虚拟内存分割为大小相等的页，通过页表将虚拟内存和物理内存映射起来
   - 因为采用的分页，所以页与页之间都是紧密排列的，不会有外部碎片，但可能页用不完，有 *内部碎片*
   - 如果物理内存不够用了，将最久未使用的页放到磁盘中，再把要使用的页放进来（因为交换的是页，比较小，交换效率高）
3. 内存段页式管理

### 51. HTTPS 如何握手流程优化

1. 启用 TLS 1.3，仅需 1-RTT 握手，比 TLS 1.2 的 2-RTT 更快
2. 预共享密钥
3. 优化数字证书的长度

### 52. NAT（网络地址抓换）

作用：将私有 IP 转换为公网 IP

类型：

- 静态 NAT：一对一固定映射
- 动态 NAT：从地址池分配临时公网 IP

### 53. 操作系统进程通信

- 管道通信：单向通信
- 消息队列
- 共享内存：线程之间
- 信号量：避免死锁

### 54. 为什么 UDP 不会粘包

因为 UDP 具有消息保护边界，每个 UDP 包中有消息头，这对于接收端来说就容易区分了。

### 55. 快排是稳定的吗？如何让他稳定

是不稳定的：在分区的过程中如果两个元素相等时可能会交换了基准元素和其他相等元素的位置。

如何稳定：

- 记录原始索引：在比较时，若元素相等的话，按照原来的顺序排
- 使用二分归并排序

### 56. UDP 传输大数据的缺陷

因为 UDP 本身不处理数据分片，超过 MTU（如 1500 字节）会导致 IP 层分片，丢失任意分片则整个报文失效

### 57. 上下文切换开销

CPU 从执行一个线程/进程切换到另一个时，需保存当前状态（寄存器、栈指针等）并加载新任务的状态

### 58. 四次挥手后客户端为什么要等待一段时间

确保最后一个 ACK 到达：若客户端直接关闭，服务端未收到 ACK 会重复发送 FIN，导致资源泄漏。

### 59. 如何判断无向图是否有环

Kahn 算法

1. 计算所有节点的入度
2. 将入度为 0 的节点加入队列
3. 依次移除队列中的节点，并减少其邻居的入度。若邻居度为 0，加入队列
4. 若最终队列中的节点长度和原始节点的长度一直，说明无环。否则有环。

### 60. 网络分层及这些层的协议

1. 应用层：HTTP DNS 
2. 传输层：TCP UDP
3. 网络层：IP ICMP（Ping） DHCP协议（分配网络配置，IP地址 等）NAT
4. 数据链路层：以太网协议（CSMA/CD 冲突检测 [发前检测 边发边检测 退避机制]） ARP 协议

### 61. TCP 解决异常断连

定义：一方已经崩溃了，无法再进行通信（和网络中断不一样，网络中断是指双方未崩溃知识网络传输过程中发生异常导致数据包无法到达）

解决：检测（TCP Keep-alive机制）

1. 空闲一段时间后（默认 2 小时），发送 Keepalive 探测包（空 ACK）。
2. 若对方无响应，重试多次（默认 9 次，间隔 75 秒）。
3. 全部失败后，判定连接失效，主动关闭。

### 62. 信号量的定义及作用

定义：是一种同步机制，用于控制多线程/进程对共享资源的访问

- `P()`（Proberen，尝试获取资源，信号量减 1，若为 0 则阻塞）
- `V()`（Verhogen，释放资源，信号量加 1，唤醒等待线程）

### 63. CPU 的结构

1. ALU（算术逻辑单元）：执行加减乘除、逻辑运算。
2. 控制单元（CU）：解码指令，协调各部件。
3. 寄存器：临时存储指令和数据（如 PC、IR）。
4. 缓存（Cache）：L1/L2/L3，减少内存访问延迟。
5. 总线接口：与内存、I/O 设备通信。

### 64. 硬链接和软连接的区别

硬链接：指向同一个 inode，每个硬链接 inode+1，删除源文件的话其他硬链接不会失效，直到 inode 为 0

软链接：指向不同的 inode，每个文件都是独立的，存储的是目标文件的路径，删除原始文件后软链接失效

### 65. 堆排序的思路

1. 将数组视为完全二叉树，调整为最大堆（父节点 ＞ 子节点）
2. 把堆顶拿出来，交换堆顶和末尾元素
3. 重新调整剩余部分最大堆，重复直到数组有序
4. $O(n\log n)$

### 66. CA 证书机制

1. 浏览器检查证书签名是否由可信 CA 签发。
2. 核对域名、有效期。
3. 证书链验证（根证书 → 中间证书 → 站点证书

防篡改：证书包含数字签名，篡改会导致校验失败
